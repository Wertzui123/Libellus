import graphics
import math
import math.geometry

class ImageDiff {

    property map<int, map<int, Color>> previousPixels = {}

    method apply(ICanvas canvas) returns ImageDiff{
        var map<int, map<int, Color>> newPreviousPixels = {}
        var list<list<int>> chunksLoaded = []
        if(canvas oftype LazyChunkedCanvas){
            foreach(previousPixels as y => row){
                newPreviousPixels[y] = {}
                foreach(row as x => color){
                    if(!LazyChunkedCanvas(canvas).isChunkLoaded(int(x / LazyChunkedCanvas:CANVAS_WIDTH), int(y / LazyChunkedCanvas:CANVAS_HEIGHT))){
                        LazyChunkedCanvas(canvas).loadChunk(int(x / LazyChunkedCanvas:CANVAS_WIDTH), int(y / LazyChunkedCanvas:CANVAS_HEIGHT))
                        chunksLoaded.add([int(x / LazyChunkedCanvas:CANVAS_WIDTH), int(y / LazyChunkedCanvas:CANVAS_HEIGHT)])
                    }
                    newPreviousPixels[y][x] = LazyChunkedCanvas(canvas).getPixel(x, y)
                    LazyChunkedCanvas(canvas).setPixel(x, y, color, false)
                }
            }
            foreach(chunksLoaded as chunk){
                LazyChunkedCanvas(canvas).unloadChunk(chunk[0], chunk[1])
            }
        }else{
            foreach(previousPixels as y => row){
                newPreviousPixels[y] = {}
                foreach(row as x => color){
                    newPreviousPixels[y][x] = canvas.getPixel(x, y)
                    canvas.setPixel(x, y, color, false)
                }
            }
        }
        var newDiff = new ImageDiff()
        newDiff.previousPixels = newPreviousPixels
        return newDiff
    }

    method track(ICanvas canvas, int x, int y){
        if(!previousPixels.containsKey(y)){
            previousPixels[y] = {}
        }
        if(previousPixels[y].containsKey(x)){
            return
        }
        previousPixels[y][x] = canvas.getPixel(x, y)
    }

    method trackIfNotNone(Canvas|ChunkedCanvas|LazyChunkedCanvas canvas, int x, int y){
        /*if(canvas oftype Canvas){
            var pixel = Canvas(canvas).getPixel(x, y)
            if(pixel.r == 0b && pixel.g == 0b && pixel.b == 0b && pixel.a == 0b){
                return
            }
        }elseif(canvas oftype ChunkedCanvas){
            var pixel = ChunkedCanvas(canvas).getPixel(x, y)
            if(pixel.r == 0b && pixel.g == 0b && pixel.b == 0b && pixel.a == 0b){
                return
            }
        }elseif(canvas oftype LazyChunkedCanvas){
            /*var pixel = LazyChunkedCanvas(canvas).getPixel(x, y)
            if(pixel.r == 0b && pixel.g == 0b && pixel.b == 0b && pixel.a == 0b){
                return
            }*/
        }
        //track(canvas, x, y)
        */
    }

    method trackDrawLine(int x1, int y1, int x2, int y2, int thickness, ICanvas canvas){
        var dx = x2 - x1
        var dy = y2 - y1
        var adx = int(math.abs(double(dx)))
        var ady = int(math.abs(double(dy)))
        var sx = 0
        if(dx > 0) {
            sx = 1
        } else {
            sx = -1
        }
        var sy = 0
        if(dy > 0) {
            sy = 1
        } else {
            sy = -1
        }
        var err = adx - ady
        var e2 = 0
        var x = x1
        var y = y1

        while(true) {
            repeat(thickness, i = 0) {
                track(canvas, x, y + i)
                track(canvas, x, y - i)
                track(canvas, x + i, y)
                track(canvas, x - i, y)
            }

            if(x == x2 && y == y2) {
                break
            }

            e2 = 2 * err
            if(e2 > -ady) {
                err -= ady
                x += sx
            }
            if(e2 < adx) {
                err += adx
                y += sy
            }
        }
    }

    method trackFillCircle(Ellipse circle, ICanvas canvas){
        var i = -int(circle.size.width)
        while(i < int(circle.size.width)) {
            var j = -int(circle.size.height)
            while(j < int(circle.size.height)) {
                if((i * i + j * j) < (circle.size.width * circle.size.width)) {
                    track(canvas, int(circle.position.x + i), int(circle.position.y + j))
                }
                j++
            }
            i++
        }
    }

    // TODO: Remove this method; it is currently here for performance reasons because trackFillCircle is too slow
    method trackFillCircleRectangular(Ellipse circle, ICanvas canvas){
        var i = -int(circle.size.width)
        while(i < int(circle.size.width)) {
            var j = -int(circle.size.height)
            while(j < int(circle.size.height)) {
                track(canvas, int(circle.position.x + i), int(circle.position.y + j))
                j++
            }
            i++
        }
    }

}