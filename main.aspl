import graphics
import math
import math.geometry
import os
import time
import io
import libellus.utils
import json

var int UNDO_REDO_LIMIT = 30

var Window window = new Window("Libellus", 500, 500)

if(!io.exists_directory(Booklet:getBookletsPath())){
    io.create_directory(Booklet:getBookletsPath())
}

foreach([
    map<string, any>{
        "name" => "Libellus",
        "color" => new Color(255, 249, 186, 5)
    },
    map<string, any>{
        "name" => "English",
        "color" => new Color(255, 0, 255, 0)
    },
    map<string, any>{
        "name" => "German",
        "color" => new Color(255, 0, 0, 255)
    },
    map<string, any>{
        "name" => "History",
        "color" => new Color(255, 128, 64, 64)
    },
    map<string, any>{
        "name" => "Math",
        "color" => new Color(255, 255, 0, 0)
    },
    map<string, any>{
        "name" => "Physics",
        "color" => new Color(255, 255, 255, 0)
    }
] as b){
    var create = false
    if(!io.exists_directory(io.join_path([Booklet:getBookletsPath(), string(b["name"])]))){
        create = true
        io.create_directory(io.join_path([Booklet:getBookletsPath(), string(b["name"])]))
    }
    if(!io.exists_directory(io.join_path([Booklet:getBookletsPath(), string(b["name"]), "sheets"]))){
        io.create_directory(io.join_path([Booklet:getBookletsPath(), string(b["name"]), "sheets"]))
    }
    if(create || !io.exists_file(io.join_path([Booklet:getBookletsPath(), string(b["name"]), "booklet.json"]))){
        io.write_file(io.join_path([Booklet:getBookletsPath(), string(b["name"]), "booklet.json"]), json.encode(map<string, any>{"color" => map<string, any>{"r" => Color(b["color"]).r, "g" => Color(b["color"]).g, "b" => Color(b["color"]).b, "a" => Color(b["color"]).a}, "sheets" => list<any>[], "scroll" => map<string, any>{"x" => 0, "y" => 0}}))
    }
}

var bookletName = "Libellus"
if(!io.exists_file(io.join_path([Booklet:getBookletsPath(), "current.txt"]))){
    io.write_file(io.join_path([Booklet:getBookletsPath(), "current.txt"]), bookletName)
}else{
    bookletName = io.read_file(io.join_path([Booklet:getBookletsPath(), "current.txt"]))
}
var list<Booklet> booklets = []
var Booklet booklet = new Booklet("Notes", new Color(255, 249, 186, 5), new LazyChunkedCanvas(window.width - get_booklet_list_width(window), window.height - get_toolbar_height(window), io.join_path([Booklet:getBookletsPath(), "Notes", "chunks"])), [], 0, 0)
var hasAnySelected = false
var bookletFolders = utils.sort_alphabetically(io.directories(Booklet:getBookletsPath()))
{
    var int i = 0
    foreach(bookletFolders as folder){
        if(i > 0 && folder == "Libellus"){
            bookletFolders.removeAt(i)
            bookletFolders.insert(0, folder)
        }
        i++
    }
}
foreach(bookletFolders as folder){
    if(!io.exists_directory(folder) && io.exists_directory(io.join_path([Booklet:getBookletsPath(), folder]))){
        folder = io.join_path([Booklet:getBookletsPath(), folder])
    }
    if(io.exists_directory(folder)){
        if(!io.exists_file(io.join_path([folder, "booklet.json"]))){
            continue
        }
        if(!io.exists_directory(io.join_path([folder, "chunks"]))){
            io.create_directory(io.join_path([folder, "chunks"]))
        }
        var data = json.decode(io.read_file(io.join_path([folder, "booklet.json"])))
        var c = new LazyChunkedCanvas(window.width - get_booklet_list_width(window), window.height - get_toolbar_height(window), io.join_path([folder, "chunks"]))
        var list<string> sheetFiles = []
        if(map<string, any>(data).containsKey("sheets")){
            foreach(list<any>(map<string, any>(data)["sheets"]) as sheet){
                sheetFiles.add(string(sheet))
            }
        }
        var scrollX = 0
        var scrollY = 0
        if(map<string, any>(data).containsKey("scroll")){
            scrollX = int(map<string, any>(map<string, any>(data)["scroll"])["x"])
            scrollY = int(map<string, any>(map<string, any>(data)["scroll"])["y"])
        }
        var Booklet b = new Booklet(io.directory_name(folder), new Color(255, byte(map<string, any>(map<string, any>(data)["color"])["r"]), byte(map<string, any>(map<string, any>(data)["color"])["g"]), byte(map<string, any>(map<string, any>(data)["color"])["b"])), c, sheetFiles, scrollX, scrollY)
        if(b.name == bookletName){
            booklet = b
            booklet.prepare()
            hasAnySelected = true
            AppState:scrollX = scrollX
            AppState:scrollY = scrollY
        }
        booklets.add(b)
    }
}
if(booklets.length == 0 || !hasAnySelected){
    booklets.add(booklet)
    if(!io.exists_directory(io.join_path([Booklet:getBookletsPath(), booklet.name, "chunks"]))){
        if(!io.exists_directory(io.join_path([Booklet:getBookletsPath(), booklet.name]))){
            io.create_directory(io.join_path([Booklet:getBookletsPath(), booklet.name]))
        }
        io.create_directory(io.join_path([Booklet:getBookletsPath(), booklet.name, "chunks"]))
    }
    if(!io.exists_directory(io.join_path([Booklet:getBookletsPath(), booklet.name, "sheets"]))){
        io.create_directory(io.join_path([Booklet:getBookletsPath(), booklet.name, "sheets"]))
    }
    booklet.prepare()
}
var Pen|CircularEraser|PathEraser pen = pens[0]
var circularEraser = new CircularEraser(30)
var pathEraser = new PathEraser()
var list<Canvas> penIcons = []
var penIconData = $embed("icons/pen.png")
var circularEraserIcon = new Canvas(1, 1)
var pathEraserIcon = new Canvas(1, 1)
var themeSwitchIcon = new Canvas(1, 1)
var gridToggleIcon = new Canvas(1, 1)
var undoIconOriginal = Canvas:fromFileData($embed("icons/undo.png"))
var redoIconOriginal = Canvas:fromFileData($embed("icons/redo.png"))
var undoIcon = new Canvas(1, 1)
var redoIcon = new Canvas(1, 1)
var imageImporterIcon = new Canvas(1, 1)
var folderIcon = new Canvas(1, 1)
var imageFileIcon = new Canvas(1, 1)
var bookletIcon = new Canvas(1, 1)
var newSheetIconOriginal = Canvas:fromFileData($embed("icons/new_sheet.png"))
var sheetCollectionHeight = 0
var list<Rectangle> sheetCollectionBounds = []
var sheetImporterHeight = 0
// TODO: The below lists should be of type ImageDiff (or LazyChunkedCanvas|Canvas with the $legacyUndoRedo flag), but due to a bug in ASPL, this is currently not possible
var list<any> undoList = []
var list<any> redoList = []
var Theme theme = Theme.Light
if(io.exists_file(io.join_path([Booklet:getBookletsPath(), "theme.txt"]))){
    var t = io.read_file(io.join_path([Booklet:getBookletsPath(), "theme.txt"]))
    if(t == "light"){
        theme = Theme.Light
    }elseif(t == "dark"){
        theme = Theme.Dark
    }
}else{
    io.write_file(io.join_path([Booklet:getBookletsPath(), "theme.txt"]), "light")
}
if(io.exists_file(io.join_path([Booklet:getBookletsPath(), "grid.txt"]))){
    AppState:gridVisible = io.read_file(io.join_path([Booklet:getBookletsPath(), "grid.txt"])) == "true"
}else{
    io.write_file(io.join_path([Booklet:getBookletsPath(), "grid.txt"]), "false")
}
var hasChanged = false
var hasChangedForOnPaint = false
var hasScrollChanged = false
var hasSizeChanged = false
var hasSizeChangedForOnPaint = false
var hasThemeChanged = false
var hasThemeChangedForOnPaint = false
var hasGridVisibilityChanged = false
var hasGridVisibilityChangedForOnPaint = false
var hasUndoAvailabilityChanged = false
var hasRedoAvailabilityChanged = false
var isMouseDown = false
var zone = Zone.Canvas
var sheetImporterPath = ""
var hasPushedUndoDiff = false
window.onMouseDown = callback(Point position, MouseButton button) {
    if(position.x > get_booklet_list_width(window) && position.y > get_toolbar_height(window)){
        if (button == MouseButton.Left){
            isMouseDown = true
            if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                if(undoList.length == 0){
                    hasUndoAvailabilityChanged = true
                }
                if(AppState:zone == Zone.Canvas){
                    $if legacyUndoRedo{
                        if(booklet.canvas.width * booklet.canvas.height > 5000000){
                            // TODO: Remove this workaround when the undo/redo system doesn't store the entire canvas in memory
                            undoList.clear()
                        }
                        undoList.add(booklet.canvas.copy())
                    }$else{
                        if(pen == pathEraser){
                            var pixel = booklet.canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                            if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                undoList.add(new ImageDiff())
                                hasPushedUndoDiff = true
                            }else{
                                hasPushedUndoDiff = false
                            }
                        }else{
                            undoList.add(new ImageDiff())
                            hasPushedUndoDiff = true
                        }
                    }
                }elseif(AppState:zone == Zone.Sheet){
                    $if legacyUndoRedo{
                        undoList.add(Sheet(booklet.currentSheet).canvas.copy())
                    }$else{
                        if(pen == pathEraser){
                            var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                            if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                undoList.add(new ImageDiff())
                                hasPushedUndoDiff = true
                            }else{
                                hasPushedUndoDiff = false
                            }
                        }else{
                            undoList.add(new ImageDiff())
                            hasPushedUndoDiff = true
                        }
                    }
                }
                if(undoList.length > UNDO_REDO_LIMIT){
                    undoList.removeAt(0)
                }
                if(hasPushedUndoDiff && redoList.length > 0){
                    redoList.clear()
                    hasRedoAvailabilityChanged = true
                }
                if(pen == circularEraser){
                    if(AppState:zone == Zone.Canvas){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), booklet.canvas)
                        }
                        booklet.canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                    }elseif(AppState:zone == Zone.Sheet){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), Sheet(booklet.currentSheet).canvas)
                        }
                        Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                    }
                }elseif(pen == pathEraser){
                    if(AppState:zone == Zone.Canvas){
                        var pixel = booklet.canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                        if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                            utils.clear_path(booklet.canvas, int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                        }
                    }elseif(AppState:zone == Zone.Sheet){
                        var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                        if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                            utils.clear_path(Sheet(booklet.currentSheet).canvas, int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                        }
                    }
                }else{
                    if(AppState:zone == Zone.Canvas){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), booklet.canvas)
                        }
                        booklet.canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Pen(pen).color)

                        // automatically resize canvas when drawing near the edge
                        if((booklet.canvas.width < ((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300)) || (booklet.canvas.height < ((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))){
                            booklet.canvas.extendTo(int(math.max(double(booklet.canvas.width), double((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300))), int(math.max(double(booklet.canvas.height), double((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))))
                        }
                    }elseif(AppState:zone == Zone.Sheet){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Sheet(booklet.currentSheet).canvas)
                        }
                        Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Pen(pen).color)
                    }
                }
                hasChanged = true
                hasChangedForOnPaint = true
                if(booklet.currentSheet != null){
                    Sheet(booklet.currentSheet).hasChanged = true
                }
            }
        }
    }
}
window.onMouseUp = callback(Point position, MouseButton button) {
    if(position.x > get_booklet_list_width(window) && position.y > get_toolbar_height(window)){
        if (button == MouseButton.Left) {
            isMouseDown = false
        }
    }
}
var currentMousePosition = new Point(-1, -1)
window.onMouseMove = callback(Point position, float deltaX, float deltaY) {
    currentMousePosition = position
    if(position.x > get_booklet_list_width(window) && position.y > get_toolbar_height(window)){
        if (isMouseDown) {
            if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                if(pen == circularEraser){
                    if(AppState:zone == Zone.Canvas){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), booklet.canvas)
                        }
                        booklet.canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                    }elseif(AppState:zone == Zone.Sheet){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX , (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), Sheet(booklet.currentSheet).canvas)
                        }
                        Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                    }
                }elseif(pen == pathEraser){
                    if(AppState:zone == Zone.Canvas){
                        var pixel = booklet.canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                        if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                            $if !legacyUndoRedo{
                                if(!hasPushedUndoDiff){
                                    undoList.add(new ImageDiff())
                                    hasPushedUndoDiff = true
                                    hasUndoAvailabilityChanged = true
                                }
                            }
                            utils.clear_path(booklet.canvas, int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                        }
                    }elseif(AppState:zone == Zone.Sheet){
                        var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                        if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                            $if !legacyUndoRedo{
                                if(!hasPushedUndoDiff){
                                    undoList.add(new ImageDiff())
                                    hasPushedUndoDiff = true
                                    hasUndoAvailabilityChanged = true
                                }
                            }
                            utils.clear_path(Sheet(booklet.currentSheet).canvas, int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                        }
                    }
                }elseif(pen oftype Pen){
                    if(AppState:zone == Zone.Canvas){
                        $if !legacyUndoRedo{
                            ImageDiff(undoList[undoList.length - 1]).trackDrawLine(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX - deltaX / AppState:zoom), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY - deltaY / AppState:zoom), int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).thickness, booklet.canvas)
                        }
                        booklet.canvas.drawLine(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX - deltaX / AppState:zoom), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY - deltaY / AppState:zoom), int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).color, Pen(pen).thickness)

                        // automatically resize canvas when drawing near the edge
                        if((booklet.canvas.width < ((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300)) || (booklet.canvas.height < ((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))){
                            booklet.canvas.extendTo(int(math.max(double(booklet.canvas.width), double((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300))), int(math.max(double(booklet.canvas.height), double((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))))
                        }
                    }elseif(AppState:zone == Zone.Sheet){
                        Sheet(booklet.currentSheet).canvas.drawLine(int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX - deltaX / AppState:zoom), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY - deltaY / AppState:zoom), int((position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).color, Pen(pen).thickness)
                    }
                }
                hasChanged = true
                hasChangedForOnPaint = true
                if(booklet.currentSheet != null){
                    Sheet(booklet.currentSheet).hasChanged = true
                }
            }
        }
    }
}
window.onMouseClick = callback(Point position, MouseButton button) {
    if (button == MouseButton.Left) {
        if(position.y < get_toolbar_height(window)){
            var i = 0
            foreach(pens as p){
                var penIcon = penIcons[i]
                if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2) + penIcon.width && position.y > get_toolbar_height(window) / 2f - penIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - penIcon.height / 2 + penIcon.height){
                    pen = p
                    return
                }
                i++
            }
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2) + circularEraserIcon.width && position.y > get_toolbar_height(window) / 2f - circularEraserIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - circularEraserIcon.height / 2 + circularEraserIcon.height){
                pen = circularEraser
                return
            }
            i++
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2) + pathEraserIcon.width && position.y > get_toolbar_height(window) / 2f - pathEraserIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - pathEraserIcon.height / 2 + pathEraserIcon.height){
                pen = pathEraser
                return
            }
            i++
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - undoIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - undoIcon.width / 2) + undoIcon.width && position.y > get_toolbar_height(window) / 2f - undoIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - undoIcon.height / 2 + undoIcon.height){
                if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                    if(undoList.length > 0){
                        if(redoList.length == 0){
                            hasRedoAvailabilityChanged = true
                        }
                        if(AppState:zone == Zone.Canvas){
                            $if legacyUndoRedo{
                                redoList.add(booklet.canvas.copy())
                                booklet.canvas = LazyChunkedCanvas(undoList[undoList.length - 1])
                            }$else{
                                redoList.add(ImageDiff(undoList[undoList.length - 1]).apply(booklet.canvas))
                            }
                        }elseif(AppState:zone == Zone.Sheet){
                            $if legacyUndoRedo{
                                redoList.add(Sheet(booklet.currentSheet).canvas.copy())
                                Sheet(booklet.currentSheet).canvas = Canvas(undoList[undoList.length - 1])
                            }$else{
                                redoList.add(ImageDiff(undoList[undoList.length - 1]).apply(Sheet(booklet.currentSheet).canvas))
                            }
                        }
                        undoList.removeAt(undoList.length - 1)
                        if(undoList.length == 0){
                            hasUndoAvailabilityChanged = true
                        }
                        hasChanged = true
                        hasChangedForOnPaint = true
                        if(booklet.currentSheet != null){
                            Sheet(booklet.currentSheet).hasChanged = true
                        }
                    }
                }
                return
            }
            i++
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - redoIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - redoIcon.width / 2) + redoIcon.width && position.y > get_toolbar_height(window) / 2f - redoIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - redoIcon.height / 2 + redoIcon.height){
                if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                    if(redoList.length > 0){
                        if(undoList.length == 0){
                            hasUndoAvailabilityChanged = true
                        }
                        if(AppState:zone == Zone.Canvas){
                            $if legacyUndoRedo{
                                undoList.add(booklet.canvas.copy())
                                booklet.canvas = LazyChunkedCanvas(redoList[redoList.length - 1])
                            }$else{
                                undoList.add(ImageDiff(redoList[redoList.length - 1]).apply(booklet.canvas))
                            }
                        }elseif(AppState:zone == Zone.Sheet){
                            $if legacyUndoRedo{
                                undoList.add(Sheet(booklet.currentSheet).canvas.copy())
                                Sheet(booklet.currentSheet).canvas = Canvas(redoList[redoList.length - 1])
                            }$else{
                                undoList.add(ImageDiff(redoList[redoList.length - 1]).apply(Sheet(booklet.currentSheet).canvas))
                            }
                        }
                        redoList.removeAt(redoList.length - 1)
                        if(redoList.length == 0){
                            hasRedoAvailabilityChanged = true
                        }
                        hasChanged = true
                        hasChangedForOnPaint = true
                        if(booklet.currentSheet != null){
                            Sheet(booklet.currentSheet).hasChanged = true
                        }
                    }
                }
                return
            }
            i++
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - imageImporterIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - imageImporterIcon.width / 2) + imageImporterIcon.width && position.y > get_toolbar_height(window) / 2f - imageImporterIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - imageImporterIcon.height / 2 + imageImporterIcon.height){
                if(AppState:zone == Zone.SheetCollection){
                    AppState:zone = Zone.Canvas
                }else{
                    AppState:zone = Zone.SheetCollection
                    hasInitializedSheetCollectionScroll = false
                }
                if(AppState:zone == Zone.Canvas){
                    AppState:scrollX = booklet.scrollX
                    AppState:scrollY = booklet.scrollY
                }else{
                    AppState:scrollX = 0
                    AppState:scrollY = 0
                }
                AppState:zoom = 1
                if(undoList.length > 0){
                    undoList.clear()
                    hasUndoAvailabilityChanged = true
                }
                if(redoList.length > 0){
                    redoList.clear()
                    hasRedoAvailabilityChanged = true
                }
                hasChangedForOnPaint = true
                return
            }
            i++
            if(AppState:zone == Zone.Canvas){
                if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - gridToggleIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - gridToggleIcon.width / 2) + gridToggleIcon.width && position.y > get_toolbar_height(window) / 2f - gridToggleIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - gridToggleIcon.height / 2 + gridToggleIcon.height){
                    if(AppState:zone == Zone.Canvas){
                        AppState:gridVisible = !AppState:gridVisible
                        hasGridVisibilityChanged = true
                        hasGridVisibilityChangedForOnPaint = true
                    }
                    return
                }
                i++
            }
            if(position.x > (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2) && position.x < (window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2) + themeSwitchIcon.width && position.y > get_toolbar_height(window) / 2f - themeSwitchIcon.height / 2 && position.y < get_toolbar_height(window) / 2f - themeSwitchIcon.height / 2 + themeSwitchIcon.height){
                if(theme == Theme.Light){
                    theme = Theme.Dark
                    hasThemeChanged = true
                    hasThemeChangedForOnPaint = true
                }else{
                    theme = Theme.Light
                    hasThemeChanged = true
                    hasThemeChangedForOnPaint = true
                }
                return
            }
        }elseif(position.x <= get_booklet_list_width(window)){
            var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 30d, 10d))).asUnderlined()
            var y = int(graphics.measure_text_size("Booklets", font).height * 3) + get_toolbar_height(window)
            font = font.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 70d, 7d)))
            var int i = 0
            foreach(booklets as b){
                var name = b.name
                if(b == booklet){
                    name += " [x]"
                }
                var size = graphics.measure_text_size(name, font)
                var height = int(size.height)
                if(position.y >= y - height * 1.5 && position.y <= y){
                    booklet.unprepare()
                    booklet = b
                    booklet.prepare()
                    if(undoList.length > 0){
                        undoList.clear()
                        hasUndoAvailabilityChanged = true
                    }
                    if(redoList.length > 0){
                        redoList.clear()
                        hasRedoAvailabilityChanged = true
                    }
                    AppState:scrollX = b.scrollX
                    AppState:scrollY = b.scrollY
                    AppState:zoom = 1
                    AppState:zone = Zone.Canvas
                    hasChanged = true
                    hasChangedForOnPaint = true
                    hasSizeChanged = true
                    hasSizeChangedForOnPaint = true
                }
                y += int(bookletIcon.height * 1.2)
                i++
            }
        }else{
            if(AppState:zone == Zone.SheetCollection){
                var int i = 0
                foreach(sheetCollectionBounds as b){
                    if(position.x >= b.position.x && position.x <= b.position.x + b.size.width && position.y >= b.position.y && position.y <= b.position.y + b.size.height){
                        if(i == 0){
                            AppState:zone = Zone.SheetImporter
                            sheetImporterPath = io.get_home_directory()
                            booklet.currentSheet = null
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                        }else{
                            AppState:zone = Zone.Sheet
                            booklet.currentSheet = booklet.sheets[i - 1]
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                        }
                    }
                    i++
                }
            }elseif(AppState:zone == Zone.SheetImporter){
                var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 50d, 7d)))
                var color = new Color(255, 0, 0, 0)
                if(theme == Theme.Dark){
                    color = new Color(255, 255, 255, 255)
                }
                var ls = utils.ls(sheetImporterPath, [".png", ".jpg", ".jpeg", ".bmp", ".tga", ".hdr"])
                var i = 0
                var factor = 20 // TODO: Do not hardcode this
                $if android{
                    factor = 40
                }
                var y = factor + get_toolbar_height(window) - AppState:scrollY
                foreach(ls as s){
                    var size = graphics.measure_text_size(s, font)
                    var width = int(size.width)
                    var height = int(size.height)
                    if(position.x >= window.width / 2 - width / 2 && position.x <= window.width / 2 + width / 2 && position.y >= y && position.y <= y + height){
                        if(io.exists_directory(io.join_path([sheetImporterPath, s]))){
                            if(s == ".."){
                                sheetImporterPath = sheetImporterPath.reverse().split("/", 2)[1].reverse()
                            }else{
                                sheetImporterPath = io.join_path([sheetImporterPath, s])
                            }
                            AppState:scrollY = 0
                        }else{
                            io.write_file_bytes(Booklet:getBookletsPath() + "/" + booklet.name + "/" + "sheets/" + s, io.read_file_bytes(io.join_path([sheetImporterPath, s])))
                            var Sheet sheet = Sheet:fromFile(Booklet:getBookletsPath() + "/" + booklet.name + "/" + "sheets/" + s)
                            booklet.sheets.add(sheet)
                            booklet.currentSheet = sheet
                            AppState:zone = Zone.Sheet
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                            sheet.hasChanged = true
                        }
                    }
                    y += factor
                    i++
                }
            }
        }
    }
}
window.onMouseWheel = callback(Point position, float deltaX, float deltaY) {
    if(position.x > get_booklet_list_width(window) && position.y > get_toolbar_height(window)){
        if(window.isKeyDown(KeyCode.left_control) || window.isKeyDown(KeyCode.right_control)){
            if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                if(deltaY > 0){
                    AppState:zoom += 0.1
                }else{
                    AppState:zoom -= 0.1
                }
                if(AppState:zoom < 0.2){
                    AppState:zoom = 0.2
                }
                if(AppState:zoom > 5){
                    AppState:zoom = 5
                }
            }
        }else{
            if(window.isKeyDown(KeyCode.left_shift) || window.isKeyDown(KeyCode.right_shift)){
                if(deltaY > 0){
                    if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                        AppState:scrollX = int(math.max(AppState:scrollX - double(deltaY * 5 / AppState:zoom), 0))
                        if(AppState:zone == Zone.Canvas){
                            booklet.scrollX = AppState:scrollX
                            hasScrollChanged = true
                        }
                    }
                }elseif(deltaY < 0){
                    if(AppState:zone == Zone.Canvas){
                        AppState:scrollX = int(math.max(math.min(AppState:scrollX - double(deltaY * 5 / AppState:zoom), double(booklet.canvas.width - window.width / AppState:zoom + get_booklet_list_width(window))), 0))
                        booklet.scrollX = AppState:scrollX
                        hasScrollChanged = true
                    }elseif(AppState:zone == Zone.Sheet){
                        AppState:scrollX = int(math.max(math.min(AppState:scrollX - double(deltaY * 5 / AppState:zoom), double(Sheet(booklet.currentSheet).canvas.width - window.width / AppState:zoom + get_booklet_list_width(window))), 0))
                    }
                }
            }else{
                if(deltaY > 0){
                    if(AppState:zone == Zone.Canvas || AppState:zone == Zone.SheetCollection || AppState:zone == Zone.Sheet || AppState:zone == Zone.SheetImporter){
                        AppState:scrollY = int(math.max(AppState:scrollY - double(deltaY * 5 / AppState:zoom), 0))
                        if(AppState:zone == Zone.Canvas){
                            booklet.scrollY = AppState:scrollY
                            hasScrollChanged = true
                        }
                    }
                }elseif(deltaY < 0){
                    if(AppState:zone == Zone.Canvas || AppState:zone == Zone.SheetCollection || AppState:zone == Zone.Sheet || AppState:zone == Zone.SheetImporter){
                        var boundHeight = booklet.canvas.height
                        if(AppState:zone == Zone.SheetCollection){
                            boundHeight = sheetCollectionHeight
                        }elseif(AppState:zone == Zone.Sheet){
                            boundHeight = Sheet(booklet.currentSheet).canvas.height
                        }elseif(AppState:zone == Zone.SheetImporter){
                            boundHeight = sheetImporterHeight
                        }
                        AppState:scrollY = int(math.max(math.min(AppState:scrollY - double(deltaY * 5 / AppState:zoom), double(boundHeight - window.height / AppState:zoom + get_toolbar_height(window))), 0))
                        if(AppState:zone == Zone.Canvas){
                            booklet.scrollY = AppState:scrollY
                            hasScrollChanged = true
                        }
                    }
                }
            }
        }
    }
}
window.onTouchDown = callback(list<TouchPoint> points){
    foreach(points as point){
        if(point.changed && point.position.x > get_booklet_list_width(window) && point.position.y > get_toolbar_height(window)){
            if(point.toolType == TouchToolType.Stylus){
                if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                    if(undoList.length == 0){
                        hasUndoAvailabilityChanged = true
                    }
                    if(AppState:zone == Zone.Canvas){
                        $if legacyUndoRedo{
                            if(booklet.canvas.width * booklet.canvas.height > 5000000){
                                // TODO: Remove this workaround when the undo/redo system doesn't store the entire canvas in memory
                                undoList.clear()
                            }
                            undoList.add(booklet.canvas.copy())
                        }$else{
                            if(pen == pathEraser){
                                var pixel = booklet.canvas.getPixel(int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                                if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                    undoList.add(new ImageDiff())
                                    hasPushedUndoDiff = true
                                }else{
                                    hasPushedUndoDiff = false
                                }
                            }else{
                                undoList.add(new ImageDiff())
                                hasPushedUndoDiff = true
                            }
                        }
                    }elseif(AppState:zone == Zone.Sheet){
                        $if legacyUndoRedo{
                            undoList.add(Sheet(booklet.currentSheet).canvas.copy())
                        }$else{
                            if(pen == pathEraser){
                                var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                                if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                    undoList.add(new ImageDiff())
                                    hasPushedUndoDiff = true
                                }else{
                                    hasPushedUndoDiff = false
                                }
                            }else{
                                undoList.add(new ImageDiff())
                                hasPushedUndoDiff = true
                            }
                        }
                    }
                    if(undoList.length > UNDO_REDO_LIMIT){
                        undoList.removeAt(0)
                    }
                    if(hasPushedUndoDiff && redoList.length > 0){
                        redoList.clear()
                        hasRedoAvailabilityChanged = true
                    }
                    if(pen == circularEraser){
                        if(AppState:zone == Zone.Canvas){
                            $if !legacyUndoRedo{
                                ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), booklet.canvas)
                            }
                            booklet.canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                        }elseif(AppState:zone == Zone.Sheet){
                            $if !legacyUndoRedo{
                                ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), Sheet(booklet.currentSheet).canvas)
                            }
                            Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                        }
                    }elseif(pen == pathEraser){
                        if(AppState:zone == Zone.Canvas){
                            var pixel = booklet.canvas.getPixel(int((point.position.x - get_booklet_list_width(window) + AppState:scrollX) / AppState:zoom), int((point.position.y - get_toolbar_height(window) + AppState:scrollY) / AppState:zoom))
                            if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                utils.clear_path(booklet.canvas, int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                            }
                        }elseif(AppState:zone == Zone.Sheet){
                            var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((point.position.x - get_booklet_list_width(window) + AppState:scrollX) / AppState:zoom), int((point.position.y - get_toolbar_height(window) + AppState:scrollY) / AppState:zoom))
                            if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                utils.clear_path(Sheet(booklet.currentSheet).canvas, int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                            }
                        }
                    }else{
                        if(AppState:zone == Zone.Canvas){
                            $if !legacyUndoRedo{
                                ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), booklet.canvas)
                            }
                            booklet.canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Pen(pen).color)

                            // automatically resize canvas when drawing near the edge
                            if((booklet.canvas.width < ((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300)) || (booklet.canvas.height < ((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))){
                                booklet.canvas.extendTo(int(math.max(double(booklet.canvas.width), double((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300))), int(math.max(double(booklet.canvas.height), double((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))))
                            }
                        }elseif(AppState:zone == Zone.Sheet){
                            $if !legacyUndoRedo{
                                ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Sheet(booklet.currentSheet).canvas)
                            }
                            Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(Pen(pen).thickness), float(Pen(pen).thickness))), Pen(pen).color)
                        }
                    }
                    hasChanged = true
                    hasChangedForOnPaint = true
                    if(booklet.currentSheet != null){
                        Sheet(booklet.currentSheet).hasChanged = true
                    }
                }
            }
        }
    }
}
var map<long, Point> touchPoints = {}
window.onTouchMove = callback(list<TouchPoint> points){
    var newScrollX = -1
    var newScrollY = -1
    var canBeZoomPoint = false
    var TouchPoint? previousZoomPoint = null
    var oldTouchPoints = touchPoints.cloneShallow()
    foreach(points as point){
        if(point.changed && point.position.x > get_booklet_list_width(window) && point.position.y > get_toolbar_height(window)){
            if(touchPoints.containsKey(point.identifier)){
                if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                    if(point.toolType == TouchToolType.Stylus){
                        if(pen == circularEraser){
                            if(AppState:zone == Zone.Canvas){
                                $if !legacyUndoRedo{
                                    ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), booklet.canvas)
                                }
                                booklet.canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                            }elseif(AppState:zone == Zone.Sheet){
                                $if !legacyUndoRedo{
                                    ImageDiff(undoList[undoList.length - 1]).trackFillCircleRectangular(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), Sheet(booklet.currentSheet).canvas)
                                }
                                Sheet(booklet.currentSheet).canvas.fillCircle(new Ellipse(new Point((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX, (point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), new Size(float(CircularEraser(pen).thickness / 2), float(CircularEraser(pen).thickness / 2))), new Color(0, 0, 0, 0), false)
                            }
                        }elseif(pen == pathEraser){
                            if(AppState:zone == Zone.Canvas){
                                var pixel = booklet.canvas.getPixel(int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                                if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                    $if !legacyUndoRedo{
                                        if(!hasPushedUndoDiff){
                                            undoList.add(new ImageDiff())
                                            hasPushedUndoDiff = true
                                            hasUndoAvailabilityChanged = true
                                        }
                                    }
                                    utils.clear_path(booklet.canvas, int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                                }
                            }elseif(AppState:zone == Zone.Sheet){
                                var pixel = Sheet(booklet.currentSheet).canvas.getPixel(int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY))
                                if(!(pixel.a == 0b && pixel.r == 0b && pixel.g == 0b && pixel.b == 0b)){
                                    $if !legacyUndoRedo{
                                        if(!hasPushedUndoDiff){
                                            undoList.add(new ImageDiff())
                                            hasPushedUndoDiff = true
                                            hasUndoAvailabilityChanged = true
                                        }
                                    }
                                    utils.clear_path(Sheet(booklet.currentSheet).canvas, int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), ImageDiff(undoList[undoList.length - 1]))
                                }
                            }
                        }elseif(pen oftype Pen){
                            if(AppState:zone == Zone.Canvas){
                                $if !legacyUndoRedo{
                                    ImageDiff(undoList[undoList.length - 1]).trackDrawLine(int((touchPoints[point.identifier].x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((touchPoints[point.identifier].y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).thickness, booklet.canvas)
                                }
                                booklet.canvas.drawLine(int((touchPoints[point.identifier].x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((touchPoints[point.identifier].y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).color, Pen(pen).thickness)

                                // automatically resize canvas when drawing near the edge
                                if((booklet.canvas.width < ((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300)) || (booklet.canvas.height < ((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))){
                                    booklet.canvas.extendTo(int(math.max(double(booklet.canvas.width), double((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX + Pen(pen).thickness + 300))), int(math.max(double(booklet.canvas.height), double((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY + Pen(pen).thickness + 300))))
                                }
                            }elseif(AppState:zone == Zone.Sheet){
                                $if !legacyUndoRedo{
                                    ImageDiff(undoList[undoList.length - 1]).trackDrawLine(int((touchPoints[point.identifier].x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((touchPoints[point.identifier].y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).thickness, Sheet(booklet.currentSheet).canvas)
                                }
                                Sheet(booklet.currentSheet).canvas.drawLine(int((touchPoints[point.identifier].x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((touchPoints[point.identifier].y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), int((point.position.x - get_booklet_list_width(window)) / AppState:zoom + AppState:scrollX), int((point.position.y - get_toolbar_height(window)) / AppState:zoom + AppState:scrollY), Pen(pen).color, Pen(pen).thickness)
                            }
                        }
                        hasChanged = true
                        hasChangedForOnPaint = true
                        if(booklet.currentSheet != null){
                            Sheet(booklet.currentSheet).hasChanged = true
                        }
                    }else{
                        if(canBeZoomPoint){
                            if(math.sqrt(math.pow(double(point.position.x - TouchPoint(previousZoomPoint).position.x), 2) + math.pow(double(point.position.y - TouchPoint(previousZoomPoint).position.y), 2)) > math.sqrt(math.pow(double(oldTouchPoints[point.identifier].x - oldTouchPoints[TouchPoint(previousZoomPoint).identifier].x), 2) + math.pow(double(oldTouchPoints[point.identifier].y - oldTouchPoints[TouchPoint(previousZoomPoint).identifier].y), 2))){
                                AppState:zoom += 0.01
                            }else{
                                AppState:zoom -= 0.01
                            }
                            if(AppState:zoom < 0.2){
                                AppState:zoom = 0.2
                            }
                            if(AppState:zoom > 5){
                                AppState:zoom = 5
                            }
                        }
                        if(AppState:zone == Zone.Canvas){
                            newScrollX = int(math.max(math.min(AppState:scrollX + double(oldTouchPoints[point.identifier].x - point.position.x) / AppState:zoom, double(booklet.canvas.width - window.width / AppState:zoom + get_booklet_list_width(window))), 0))
                            newScrollY = int(math.max(math.min(AppState:scrollY + double(oldTouchPoints[point.identifier].y - point.position.y) / AppState:zoom, double(booklet.canvas.height - window.height / AppState:zoom + get_toolbar_height(window))), 0))
                        }elseif(AppState:zone == Zone.Sheet){
                            newScrollX = int(math.max(math.min(AppState:scrollX + double(oldTouchPoints[point.identifier].x - point.position.x) / AppState:zoom, double(Sheet(booklet.currentSheet).canvas.width - window.width / AppState:zoom + get_booklet_list_width(window))), 0))
                            var sheetHeight = Sheet(booklet.currentSheet).canvas.height
                            $if android{
                                sheetHeight += window.height / 5 // Add a bit of padding at the bottom (otherwise one may accidentally click on the home button)
                            }
                            newScrollY = int(math.max(math.min(AppState:scrollY + double(oldTouchPoints[point.identifier].y - point.position.y) / AppState:zoom, double(sheetHeight - window.height / AppState:zoom + get_toolbar_height(window))), 0))
                        }
                        canBeZoomPoint = true
                        previousZoomPoint = point
                    }
                }elseif(AppState:zone == Zone.SheetCollection){
                    if(point.toolType != TouchToolType.Stylus){
                        newScrollY = int(math.max(math.min(AppState:scrollY + double(touchPoints[point.identifier].y - point.position.y) / AppState:zoom, double(sheetCollectionHeight - window.height + get_toolbar_height(window))), 0))
                    }
                }elseif(AppState:zone == Zone.SheetImporter){
                    if(point.toolType != TouchToolType.Stylus){
                        newScrollY = int(math.max(math.min(AppState:scrollY + double(touchPoints[point.identifier].y - point.position.y) / AppState:zoom, double(sheetImporterHeight - window.height + get_toolbar_height(window))), 0))
                    }
                }
            }
            touchPoints[point.identifier] = point.position
        }
    }
    if(newScrollX != -1){
        AppState:scrollX = newScrollX
        if(AppState:zone == Zone.Canvas){
            booklet.scrollX = AppState:scrollX
            hasScrollChanged = true
        }
    }
    if(newScrollY != -1){
        AppState:scrollY = newScrollY
        if(AppState:zone == Zone.Canvas){
            booklet.scrollY = AppState:scrollY
            hasScrollChanged = true
        }
    }
}
window.onTouchUp = callback(list<TouchPoint> points){
    foreach(points as point){
        if(point.changed){
            if(point.position.x > get_booklet_list_width(window) && point.position.y > get_toolbar_height(window)){
                if(touchPoints.containsKey(point.identifier)){
                    touchPoints.remove(point.identifier)
                }
            }elseif(point.position.x <= get_booklet_list_width(window) && point.position.y >= get_toolbar_height(window)){
                var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 30d, 10d))).asUnderlined()
                var y = int(graphics.measure_text_size("Booklets", font).height * 3) + get_toolbar_height(window)
                font = font.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 70d, 7d)))
                var int i = 0
                foreach(booklets as b){
                    var name = b.name
                    if(b == booklet){
                        name += " [x]"
                    }
                    var size = graphics.measure_text_size(name, font)
                    var height = int(size.height)
                    if(point.position.x <= get_booklet_list_width(window) && point.position.y >= y - height * 1.5 && point.position.y <= y){
                        booklet.unprepare()
                        booklet = b
                        booklet.prepare()
                        if(undoList.length > 0){
                            undoList.clear()
                            hasUndoAvailabilityChanged = true
                        }        
                        if(redoList.length > 0){
                            redoList.clear()
                            hasRedoAvailabilityChanged = true
                        }
                        AppState:scrollX = booklet.scrollX
                        AppState:scrollY = booklet.scrollY
                        AppState:zoom = 1
                        AppState:zone = Zone.Canvas
                        hasChanged = true
                        hasChangedForOnPaint = true
                        hasSizeChanged = true
                        hasSizeChangedForOnPaint = true
                    }
                    y += int(bookletIcon.height * 1.2)
                    i++
                }
            }else{
                var i = 0
                foreach(pens as p){
                    var penIcon = penIcons[i]
                    penIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
                    if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2 + penIcon.width && point.position.y > get_toolbar_height(window) / 2f - penIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - penIcon.height / 2 + penIcon.height){
                        pen = p
                        return
                    }
                    i++
                }
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2 + circularEraserIcon.width && point.position.y > get_toolbar_height(window) / 2f - circularEraserIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - circularEraserIcon.height / 2 + circularEraserIcon.height){
                    pen = circularEraser
                    return
                }
                i++
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2 + pathEraserIcon.width && point.position.y > get_toolbar_height(window) / 2f - pathEraserIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - pathEraserIcon.height / 2 + pathEraserIcon.height){
                    pen = pathEraser
                    return
                }
                i++
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - undoIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - undoIcon.width / 2 + undoIcon.width && point.position.y > get_toolbar_height(window) / 2f - undoIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - undoIcon.height / 2 + undoIcon.height){
                    if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                        if(undoList.length > 0){
                            if(redoList.length == 0){
                                hasRedoAvailabilityChanged = true
                            }
                            if(AppState:zone == Zone.Canvas){
                                $if legacyUndoRedo{
                                    redoList.add(booklet.canvas.copy())
                                    booklet.canvas = LazyChunkedCanvas(undoList[undoList.length - 1])
                                }$else{
                                    redoList.add(ImageDiff(undoList[undoList.length - 1]).apply(booklet.canvas))
                                }
                            }elseif(AppState:zone == Zone.Sheet){
                                $if legacyUndoRedo{
                                    redoList.add(Sheet(booklet.currentSheet).canvas.copy())
                                    Sheet(booklet.currentSheet).canvas = Canvas(undoList[undoList.length - 1])
                                }$else{
                                    redoList.add(ImageDiff(undoList[undoList.length - 1]).apply(Sheet(booklet.currentSheet).canvas))
                                }
                            }
                            undoList.removeAt(undoList.length - 1)
                            if(undoList.length == 0){
                                hasUndoAvailabilityChanged = true
                            }
                            hasChanged = true
                            hasChangedForOnPaint = true
                            if(booklet.currentSheet != null){
                                Sheet(booklet.currentSheet).hasChanged = true
                            }
                        }
                    }
                    return
                }
                i++
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - redoIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - redoIcon.width / 2 + redoIcon.width && point.position.y > get_toolbar_height(window) / 2f - redoIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - redoIcon.height / 2 + redoIcon.height){
                    if(AppState:zone == Zone.Canvas || AppState:zone == Zone.Sheet){
                        if(redoList.length > 0){
                            if(undoList.length == 0){
                                hasUndoAvailabilityChanged = true
                            }
                            if(AppState:zone == Zone.Canvas){
                                $if legacyUndoRedo{
                                    undoList.add(booklet.canvas.copy())
                                    booklet.canvas = LazyChunkedCanvas(redoList[redoList.length - 1])
                                }$else{
                                    undoList.add(ImageDiff(redoList[redoList.length - 1]).apply(booklet.canvas))
                                }
                            }elseif(AppState:zone == Zone.Sheet){
                                $if legacyUndoRedo{
                                    undoList.add(Sheet(booklet.currentSheet).canvas.copy())
                                    Sheet(booklet.currentSheet).canvas = Canvas(redoList[redoList.length - 1])
                                }$else{
                                    undoList.add(ImageDiff(redoList[redoList.length - 1]).apply(Sheet(booklet.currentSheet).canvas))
                                }
                            }
                            redoList.removeAt(redoList.length - 1)
                            if(redoList.length == 0){
                                hasRedoAvailabilityChanged = true
                            }
                            hasChanged = true
                            hasChangedForOnPaint = true
                            if(booklet.currentSheet != null){
                                Sheet(booklet.currentSheet).hasChanged = true
                            }
                        }
                    }
                    return
                }
                i++
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - imageImporterIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - imageImporterIcon.width / 2 + imageImporterIcon.width && point.position.y > get_toolbar_height(window) / 2f - imageImporterIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - imageImporterIcon.height / 2 + imageImporterIcon.height){
                    if(AppState:zone == Zone.SheetCollection){
                        AppState:zone = Zone.Canvas
                    }else{
                        AppState:zone = Zone.SheetCollection
                        hasInitializedSheetCollectionScroll = false
                    }
                    if(AppState:zone == Zone.Canvas){
                        AppState:scrollX = booklet.scrollX
                        AppState:scrollY = booklet.scrollY
                    }else{
                        AppState:scrollX = 0
                        AppState:scrollY = 0
                    }
                    AppState:zoom = 1
                    if(undoList.length > 0){
                        undoList.clear()
                        hasUndoAvailabilityChanged = true
                    }
                    if(redoList.length > 0){
                        redoList.clear()
                        hasRedoAvailabilityChanged = true
                    }
                    hasChangedForOnPaint = true
                    return
                }
                i++
                if(AppState:zone == Zone.Canvas){
                    if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - gridToggleIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - gridToggleIcon.width / 2 + gridToggleIcon.width && point.position.y > get_toolbar_height(window) / 2f - gridToggleIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - gridToggleIcon.height / 2 + gridToggleIcon.height){
                        if(AppState:zone == Zone.Canvas){
                            AppState:gridVisible = !AppState:gridVisible
                            hasGridVisibilityChanged = true
                            hasGridVisibilityChangedForOnPaint = true
                        }
                        return
                    }
                    i++
                }
                if(point.position.x > window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2 && point.position.x < window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2 + themeSwitchIcon.width && point.position.y > get_toolbar_height(window) / 2f - themeSwitchIcon.height / 2 && point.position.y < get_toolbar_height(window) / 2f - themeSwitchIcon.height / 2 + themeSwitchIcon.height){
                    if(theme == Theme.Light){
                        theme = Theme.Dark
                        hasThemeChanged = true
                        hasThemeChangedForOnPaint = true
                    }else{
                        theme = Theme.Light
                        hasThemeChanged = true
                        hasThemeChangedForOnPaint = true
                    }
                    return
                }
            }
            if(AppState:zone == Zone.SheetCollection){
                var int i = 0
                foreach(sheetCollectionBounds as b){
                    if(point.position.x >= b.position.x && point.position.x <= b.position.x + b.size.width && point.position.y >= b.position.y && point.position.y <= b.position.y + b.size.height){
                        if(i == 0){
                            AppState:zone = Zone.SheetImporter
                            $if android{
                                sheetImporterPath = "/storage/emulated/0"
                            }$else{
                                sheetImporterPath = io.get_home_directory()
                            }
                            booklet.currentSheet = null
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                        }else{
                            AppState:zone = Zone.Sheet
                            booklet.currentSheet = booklet.sheets[i - 1]
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                        }
                    }
                    i++
                }
            }elseif(AppState:zone == Zone.SheetImporter){
                var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 50d, 7d)))
                var color = new Color(255, 0, 0, 0)
                if(theme == Theme.Dark){
                    color = new Color(255, 255, 255, 255)
                }
                var ls = utils.ls(sheetImporterPath, [".png", ".jpg", ".jpeg", ".bmp", ".tga", ".hdr"])
                var i = 0
                var factor = 20 // TODO: Do not hardcode this
                $if android{
                    factor = 40
                }
                var y = factor + get_toolbar_height(window) - AppState:scrollY
                foreach(ls as s){
                    var size = graphics.measure_text_size(s, font)
                    var width = int(size.width)
                    var height = int(size.height)
                    if(point.position.x >= window.width / 2 - width / 2 && point.position.x <= window.width / 2 + width / 2 && point.position.y >= y && point.position.y <= y + height){
                        if(io.exists_directory(io.join_path([sheetImporterPath, s]))){
                            if(s == ".."){
                                sheetImporterPath = sheetImporterPath.reverse().split("/", 2)[1].reverse()
                                $if android{
                                    if(sheetImporterPath == "/storage/emulated"){
                                        sheetImporterPath = "/storage/emulated/0"
                                    }
                                }
                            }else{
                                sheetImporterPath = io.join_path([sheetImporterPath, s])
                            }
                            AppState:scrollY = 0
                        }else{
                            io.write_file_bytes(Booklet:getBookletsPath() + "/" + booklet.name + "/" + "sheets/" + s, io.read_file_bytes(io.join_path([sheetImporterPath, s])))
                            var Sheet sheet = Sheet:fromFile(Booklet:getBookletsPath() + "/" + booklet.name + "/" + "sheets/" + s)
                            booklet.sheets.add(sheet)
                            booklet.currentSheet = sheet
                            AppState:zone = Zone.Sheet
                            AppState:scrollX = 0
                            AppState:scrollY = 0
                            AppState:zoom = 1
                            hasChanged = true
                            hasChangedForOnPaint = true
                            hasSizeChanged = true
                            hasSizeChangedForOnPaint = true
                            sheet.hasChanged = true
                        }
                    }
                    y += factor
                    i++
                }
            }
        }
    }
}
window.onKeyPress = callback(KeyCode key) {
    if(key == KeyCode.s){
        save(booklet, theme, hasChanged, true)
        hasChanged = false
        hasScrollChanged = false
    }
}
var logo = new Canvas(1, 1)
window.onPaint = callback(Canvas c) {
    if(theme == Theme.Light){
        c.fill(new Color(255, 255, 255, 255), false) // no blend for performance reasons
    }else{
        c.fill(new Color(255, 20, 20, 20), false) // no blend for performance reasons
    }
    if(zone == Zone.Canvas){
        booklet.canvas.requireArea(AppState:scrollX, AppState:scrollY, int(math.min(double(window.width - get_booklet_list_width(window)) / AppState:zoom, double(booklet.canvas.width - AppState:scrollX))), int(math.min(double(window.height - get_toolbar_height(window)) / AppState:zoom, double(booklet.canvas.height - AppState:scrollY))))
        var canv = booklet.canvas.getSubImage(AppState:scrollX, AppState:scrollY, int(math.min(double(window.width - get_booklet_list_width(window)) / AppState:zoom, double(booklet.canvas.width - AppState:scrollX))), int(math.min(double(window.height - get_toolbar_height(window)) / AppState:zoom, double(booklet.canvas.height - AppState:scrollY))))
        if(theme == Theme.Dark){
            canv.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
        }
        canv.resizeScale(AppState:zoom)
        if(AppState:gridVisible){
            var gridCanvas = new Canvas(canv.width, canv.height)
            if(theme == Theme.Light){
                gridCanvas.fill(new Color(255, 255, 255, 255), false) // no blend for performance reasons
            }elseif(theme == Theme.Dark){
                gridCanvas.fill(new Color(255, 20, 20, 20), false) // no blend for performance reasons
            }
            utils.draw_grid(gridCanvas, theme)
            c.drawImage(gridCanvas, get_booklet_list_width(window), get_toolbar_height(window), false) // no blend for performance reasons
        }
        c.drawImage(canv, get_booklet_list_width(window), get_toolbar_height(window))//, false) // no blend for performance reasons
    }elseif(AppState:zone == Zone.SheetCollection){
        var y = 10
        var newSheetIcon = newSheetIconOriginal.copy()
        if(theme == Theme.Dark){
            newSheetIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
        }
        newSheetIcon.resize(int(math.sqrt(double(window.width * window.height)) / 6), int(math.sqrt(double(window.width * window.height)) / 6))
        c.drawImage(newSheetIcon, get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - newSheetIcon.width / 2f) - AppState:scrollX, get_toolbar_height(window) + y - AppState:scrollY)
        sheetCollectionBounds = []
        sheetCollectionBounds.add(new Rectangle(new Point(float(get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - newSheetIcon.width / 2f) - AppState:scrollX), float(get_toolbar_height(window) + y - AppState:scrollY)), new Size(float(newSheetIcon.width), float(newSheetIcon.height))))
        y += newSheetIcon.height + 10
        foreach(booklet.sheets as sheet){
            var scaleFactor = math.min(c.width / double(sheet.canvas.width), c.height / double(sheet.canvas.height)) * 0.5
            var imgWidth = int(sheet.canvas.width * scaleFactor)
            var imgHeight = int(sheet.canvas.height * scaleFactor)
            if((get_toolbar_height(window) + y - AppState:scrollY + imgHeight >= 0) && (get_toolbar_height(window) + y - AppState:scrollY < c.height)){
                var img = sheet.sheetCanvas.copy()
                img.resize(imgWidth, imgHeight)
                c.drawImage(img, get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - img.width / 2f) - AppState:scrollX, get_toolbar_height(window) + y - AppState:scrollY, false) // no blend for performance reasons
                img = sheet.canvas.copy()
                img.resize(imgWidth, imgHeight)
                c.drawImage(img, get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - img.width / 2f) - AppState:scrollX, get_toolbar_height(window) + y - AppState:scrollY)
                c.drawRectangle(new Rectangle(new Point(float(get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - img.width / 2f) - AppState:scrollX) - 1, float(get_toolbar_height(window) + y - AppState:scrollY) - 1), new Size(float(img.width) + 2, float(img.height) + 2)), new Color(255, 0, 0, 0)) // TODO: The rectangle is sometimes off a a bit (1 pixel too wide and the upper left corner is 1 pixel too high)
            }
            sheetCollectionBounds.add(new Rectangle(new Point(float(get_booklet_list_width(window) + int((window.width - get_booklet_list_width(window)) / 2f - imgWidth / 2f) - AppState:scrollX), float(get_toolbar_height(window) + y - AppState:scrollY)), new Size(float(imgWidth), float(imgHeight))))
            y += imgHeight + 10
        }
        sheetCollectionHeight = y
    }elseif(AppState:zone == Zone.Sheet){
        var sheetCanv = Sheet(booklet.currentSheet).sheetCanvas.getSubImage(AppState:scrollX, AppState:scrollY, int(math.min(double(window.width - get_booklet_list_width(window)) / AppState:zoom, double(Sheet(booklet.currentSheet).sheetCanvas.width - AppState:scrollX))), int(math.min(double(window.height - get_toolbar_height(window)) / AppState:zoom, double(Sheet(booklet.currentSheet).sheetCanvas.height - AppState:scrollY))))
        sheetCanv.resizeScale(AppState:zoom)
        c.drawImage(sheetCanv, get_booklet_list_width(window), get_toolbar_height(window), false) // no blend for performance reasons

        var canv = Sheet(booklet.currentSheet).canvas.getSubImage(AppState:scrollX, AppState:scrollY, int(math.min(double(window.width - get_booklet_list_width(window)) / AppState:zoom, double(Sheet(booklet.currentSheet).canvas.width - AppState:scrollX))), int(math.min(double(window.height - get_toolbar_height(window)) / AppState:zoom, double(Sheet(booklet.currentSheet).canvas.height - AppState:scrollY))))
        // Do not replace dark ink since we assume sheets always have a white background
        canv.resizeScale(AppState:zoom)
        c.drawImage(canv, get_booklet_list_width(window), get_toolbar_height(window))
    }elseif(AppState:zone == Zone.SheetImporter){
        var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 50d, 7d)))
        var color = new Color(255, 0, 0, 0)
        if(theme == Theme.Dark){
            color = new Color(255, 255, 255, 255)
        }
        var ls = utils.ls(sheetImporterPath, [".png", ".jpg", ".jpeg", ".bmp", ".tga", ".hdr"])
        var i = 0
        var factor = 20 // TODO: Do not hardcode this
        $if android{
            factor = 40
        }
        if(folderIcon.width == 1 || hasThemeChangedForOnPaint || hasSizeChangedForOnPaint){
            folderIcon = Canvas:fromFileData($embed("icons/folder.png"))
            folderIcon.resize(int(factor * 0.8), int(factor * 0.8))
        }
        if(imageFileIcon.width == 1 || hasThemeChangedForOnPaint || hasSizeChangedForOnPaint){
            imageFileIcon = Canvas:fromFileData($embed("icons/image_file.png"))
            if(theme == Theme.Dark){
                imageFileIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
            }
            imageFileIcon.resize(int(factor * 0.8), int(factor * 0.8))
        }
        foreach(ls as s){
            var box = graphics.measure_text_size(s, font)
            if(io.exists_directory(io.join_path([sheetImporterPath, s]))){
                c.drawImage(folderIcon, int((c.width / 2) - box.width / 2 - folderIcon.width * 1.5), (i + 1) * factor + get_toolbar_height(window) - AppState:scrollY - int(folderIcon.height / 2 - box.height / 2))
            }else{
                c.drawImage(imageFileIcon, int((c.width / 2) - box.width / 2 - imageFileIcon.width * 1.5), (i + 1) * factor + get_toolbar_height(window) - AppState:scrollY - int(imageFileIcon.height / 2 - box.height / 2))
            }
            c.drawText(s, c.width / 2, (i + 1) * factor + get_toolbar_height(window) - AppState:scrollY, font, color, HorizontalAlignment.Center, VerticalAlignment.Top)
            i++
        }
        sheetImporterHeight = (i + 1) * factor
        $if android{
            sheetImporterHeight += window.height / 5 // Add a bit of padding at the bottom (otherwise one may accidentally click on the home button)
        }
    }
    if(theme == Theme.Light){
        c.fillRectangle(new Rectangle(new Point(0, 0), new Size(float(window.width + get_booklet_list_width(window)), float(get_toolbar_height(window)))), new Color(255, 230, 230, 234), false) // no blend for performance reasons
        c.fillRectangle(new Rectangle(new Point(0, 0), new Size(float(get_booklet_list_width(window)), float(window.height))), new Color(255, 230, 230, 234), false) // no blend for performance reasons
    }elseif(theme == Theme.Dark){
        c.fillRectangle(new Rectangle(new Point(0, 0), new Size(float(window.width + get_booklet_list_width(window)), float(get_toolbar_height(window)))), new Color(255, 26, 22, 30), false) // no blend for performance reasons
        c.fillRectangle(new Rectangle(new Point(0, 0), new Size(float(get_booklet_list_width(window)), float(window.height))), new Color(255, 26, 22, 30), false) // no blend for performance reasons
    }

    var i = 0
    foreach(pens as p){
        if(penIcons.length < i + 1){
            var icon = Canvas:fromFileData(penIconData)
            var color = p.color
            if(theme == Theme.Dark && color.r == 0b && color.g == 0b && color.b == 0b){
                color = new Color(255, 255, 255, 255)
            }
            icon.replaceColor(new Color(255, 128, 128, 128), color)
            icon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
            penIcons.add(icon)
        }
        if(hasSizeChangedForOnPaint || hasThemeChangedForOnPaint){
            var icon = Canvas:fromFileData(penIconData)
            var color = p.color
            if(theme == Theme.Dark && color.r == 0b && color.g == 0b && color.b == 0b){
                color = new Color(255, 255, 255, 255)
            }
            icon.replaceColor(new Color(255, 128, 128, 128), color)
            icon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
            penIcons[i] = icon
        }
        var penIcon = penIcons[i]
        if(p == pen){
            if(theme == Theme.Light){
                c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2) + penIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(penIcon.width * 0.75), float(penIcon.height * 0.75))), new Color(255, 210, 210, 210))
            }elseif(theme == Theme.Dark){
                c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2) + penIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(penIcon.width * 0.75), float(penIcon.height * 0.75))), new Color(50, 230, 230, 230))
            }
        }
        c.drawImage(penIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - penIcon.width / 2), int(get_toolbar_height(window) / 2 - penIcon.height / 2))
        i++
    }
    
    if(hasSizeChangedForOnPaint || circularEraserIcon.width == 1){
        circularEraserIcon = Canvas:fromFileData($embed("icons/circular_eraser.png"))
        circularEraserIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    if(pen == circularEraser){
        if(theme == Theme.Light){
            c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2) + circularEraserIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(circularEraserIcon.width * 0.75), float(circularEraserIcon.height * 0.75))), new Color(255, 210, 210, 210))
        }elseif(theme == Theme.Dark){
            c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2) + circularEraserIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(circularEraserIcon.width * 0.75), float(circularEraserIcon.height * 0.75))), new Color(50, 230, 230, 230))
        }
    }
    c.drawImage(circularEraserIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - circularEraserIcon.width / 2), int(get_toolbar_height(window) / 2 - circularEraserIcon.height / 2))

    if(AppState:zone == Zone.Canvas){
        if(pen == circularEraser && currentMousePosition != null){
            if(currentMousePosition.x > get_booklet_list_width(window) && currentMousePosition.y > get_toolbar_height(window)){
                if(theme == Theme.Light){
                    c.fillCircle(new Ellipse(new Point(float(currentMousePosition.x), float(currentMousePosition.y)), new Size(float(circularEraser.thickness / 2), float(circularEraser.thickness / 2))), new Color(128, 210, 210, 210))
                }elseif(theme == Theme.Dark){
                    c.fillCircle(new Ellipse(new Point(float(currentMousePosition.x), float(currentMousePosition.y)), new Size(float(circularEraser.thickness / 2), float(circularEraser.thickness / 2))), new Color(128, 230, 230, 230))
                }
            }
        }
    }

    i++
    if(hasSizeChangedForOnPaint || pathEraserIcon.width == 1){
        pathEraserIcon = Canvas:fromFileData($embed("icons/pen.png"))
        pathEraserIcon.replaceColor(new Color(255, 128, 128, 128), new Color(255, 255, 192, 203))
        pathEraserIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    if(pen == pathEraser){
        if(theme == Theme.Light){
            c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2) + pathEraserIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(pathEraserIcon.width * 0.75), float(pathEraserIcon.height * 0.75))), new Color(255, 210, 210, 210))
        }elseif(theme == Theme.Dark){
            c.fillCircle(new Ellipse(new Point(float(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2) + pathEraserIcon.width / 2, float(get_toolbar_height(window) / 2)), new Size(float(pathEraserIcon.width * 0.75), float(pathEraserIcon.height * 0.75))), new Color(50, 210, 210, 210))
        }
    }
    c.drawImage(pathEraserIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - pathEraserIcon.width / 2), int(get_toolbar_height(window) / 2 - pathEraserIcon.height / 2))

    i++
    if(undoIcon.width == 1 || hasSizeChangedForOnPaint || hasThemeChangedForOnPaint || hasUndoAvailabilityChanged){
        undoIcon = undoIconOriginal.copy()
        if(undoList.length > 0){
            if(theme == Theme.Dark){
                undoIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
            }
        }else{
            undoIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 128, 128, 128))
        }
        undoIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    if(hasUndoAvailabilityChanged){
        hasUndoAvailabilityChanged = false
    }
    c.drawImage(undoIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - undoIcon.width / 2), int(get_toolbar_height(window) / 2 - undoIcon.height / 2))
    i++
    if(redoIcon.width == 1 || hasSizeChangedForOnPaint || hasThemeChangedForOnPaint || hasRedoAvailabilityChanged){
        redoIcon = redoIconOriginal.copy()
        if(redoList.length > 0){
            if(theme == Theme.Dark){
                redoIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
            }
        }else{
            redoIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 128, 128, 128))
        }
        redoIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    if(hasRedoAvailabilityChanged){
        hasRedoAvailabilityChanged = false
    }
    c.drawImage(redoIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - redoIcon.width / 2), int(get_toolbar_height(window) / 2 - redoIcon.height / 2))

    i++
    if(imageImporterIcon.width == 1 || hasThemeChangedForOnPaint || hasSizeChangedForOnPaint){
        imageImporterIcon = Canvas:fromFileData($embed("icons/image_importer.png"))
        if(theme == Theme.Dark){
            imageImporterIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
        }
        imageImporterIcon.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    c.drawImage(imageImporterIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - imageImporterIcon.width / 2), int(get_toolbar_height(window) / 2 - imageImporterIcon.height / 2))
    i++

    if(hasSizeChangedForOnPaint || logo.width == 1){
        logo = Canvas:fromFileData($embed("logo.png"))
        logo.resize(int(get_toolbar_height(window) * 0.5), int(get_toolbar_height(window) * 0.5))
    }
    c.drawImage(logo, int(get_booklet_list_width(window) / 2 - logo.width / 2), int(get_toolbar_height(window) / 2 - logo.height / 2))

    if(hasSizeChangedForOnPaint || bookletIcon.width == 1 || hasThemeChangedForOnPaint){
        bookletIcon = Canvas:fromFileData($embed("icons/booklet.png"))
        if(theme == Theme.Dark){
            bookletIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 200, 200, 200))
        }
        bookletIcon.resize(int(get_toolbar_height(window) * 0.2), int(get_toolbar_height(window) * 0.2))
    }
    var textColor = new Color(255, 0, 0, 0)
    if(theme == Theme.Dark){
        textColor = new Color(255, 255, 255, 255)
    }
    var font = Font:default.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 30d, 10d))).asUnderlined()
    c.drawText("Booklets", int(get_booklet_list_width(window) / 2), get_toolbar_height(window), font, textColor, HorizontalAlignment.Center, VerticalAlignment.Top)
    var y = int(graphics.measure_text_size("Booklets", font).height * 3) + get_toolbar_height(window)
    font = font.withSize(int(math.max(int(math.sqrt(double(window.width * window.height))) / 70d, 7d)))
    foreach(booklets as b){
        var name = b.name
        if(b == booklet){
            name += " [x]"
        }
        c.drawText(name, int(get_booklet_list_width(window) / 10) + bookletIcon.width, y, font, textColor, HorizontalAlignment.Left, VerticalAlignment.Center)
        var size = graphics.measure_text_size(name, font)
        // TODO: The below rectangle calculation is implemented badly and based on guessings
        var scaleFactor = bookletIcon.width / 74f // TODO: Do not hardcode the origin size
        var w = 30 * scaleFactor
        var h = 10 * scaleFactor
        c.fillRectangle(new Rectangle(new Point(get_booklet_list_width(window) / 10 + 22 * scaleFactor, y - size.height * 2 + bookletIcon.height - 15 * scaleFactor), new Size(w, h)), b.color)
        c.drawImage(bookletIcon, int(get_booklet_list_width(window) / 10), int(y - size.height * 2))
        y += int(bookletIcon.height * 1.2)
    }

    if(AppState:zone == Zone.Canvas){
        if(hasSizeChangedForOnPaint || gridToggleIcon.width == 1 || hasGridVisibilityChangedForOnPaint){
            gridToggleIcon = Canvas:fromFileData($embed("icons/grid.png"))
            if(theme == Theme.Dark){
                gridToggleIcon.replaceColor(new Color(255, 0, 0, 0), new Color(255, 255, 255, 255))
            }
            gridToggleIcon.resize(int(math.sqrt(double(window.width * window.height)) / 20), int(math.sqrt(double(window.width * window.height)) / 20))
        }
        c.drawImage(gridToggleIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - gridToggleIcon.width / 2), int(get_toolbar_height(window) / 2 - gridToggleIcon.height / 2))
        i++
    }

    if(theme == Theme.Dark){
        if(hasSizeChangedForOnPaint || themeSwitchIcon.width == 1 || hasThemeChangedForOnPaint){
            themeSwitchIcon = Canvas:fromFileData($embed("icons/sun.png"))
            themeSwitchIcon.resize(int(math.sqrt(double(window.width * window.height)) / 20), int(math.sqrt(double(window.width * window.height)) / 20))
        }
        c.drawImage(themeSwitchIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2), int(get_toolbar_height(window) / 2 - themeSwitchIcon.height / 2))
    }else{
        if(hasSizeChangedForOnPaint || themeSwitchIcon.width == 1 || hasThemeChangedForOnPaint){
            themeSwitchIcon = Canvas:fromFileData($embed("icons/moon.png"))
            themeSwitchIcon.resize(int(math.sqrt(double(window.width * window.height)) / 20), int(math.sqrt(double(window.width * window.height)) / 20))
        }
        c.drawImage(themeSwitchIcon, int(window.width / float(get_toolbar_items_count()) * (i + 1) + get_booklet_list_width(window) - themeSwitchIcon.width / 2), int(get_toolbar_height(window) / 2 - themeSwitchIcon.height / 2))
    }
    i++

    if(hasChangedForOnPaint){
        hasChangedForOnPaint = false
    }
    if(hasSizeChangedForOnPaint){
        hasSizeChangedForOnPaint = false
    }
    if(hasThemeChangedForOnPaint){
        hasThemeChangedForOnPaint = false
    }

    if(AppState:zone == Zone.Canvas){
        ScrollbarUtils:renderScrollbars(new Size(float(booklet.canvas.width), float(booklet.canvas.height)), c, window)
    }elseif(AppState:zone == Zone.SheetCollection){
        ScrollbarUtils:renderScrollbars(new Size(float(c.width - get_booklet_list_width(window)), float(sheetCollectionHeight)), c, window)
    }elseif(AppState:zone == Zone.Sheet){
        ScrollbarUtils:renderScrollbars(new Size(float(Sheet(booklet.currentSheet).canvas.width), float(Sheet(booklet.currentSheet).canvas.height)), c, window)
    }elseif(AppState:zone == Zone.SheetImporter){
        ScrollbarUtils:renderScrollbars(new Size(float(c.width - get_booklet_list_width(window)), float(sheetImporterHeight)), c, window)
    }

    $if showFPS{
        var fpsColor = new Color(255, 0, 0, 0)
        if(theme == Theme.Dark){
            fpsColor = new Color(255, 255, 255, 255)
        }
        c.drawText("FPS: " + window.fps, 0, 0, Font:default.withSize(10), fpsColor, HorizontalAlignment.Left, VerticalAlignment.Top)
    }
}
window.onResize = callback(int width, int height) {
    booklet.canvas.extendTo(int(math.max(double(booklet.canvas.width), double(width - get_booklet_list_width(window, width, height)))), int(math.max(double(booklet.canvas.height), double(height - get_toolbar_height(window, width, height)))))
    hasSizeChanged = true
    hasSizeChangedForOnPaint = true
}
$if !noAutoSave{
    callback(){
        while(true){
            if(hasChanged || hasThemeChanged || hasScrollChanged || hasGridVisibilityChanged){
                var hadChanged = hasChanged
                hasChanged = false
                hasScrollChanged = false
                save(booklet, theme, hadChanged)
            }
            time.sleep(1)
        }
    }.+()
}
window.show()

function get_toolbar_height(Window window, int width = -1, int height = -1) returns int{
    if(width < 0){
        width = window.width
    }
    if(height < 0){
        height = window.height
    }
    return int(math.sqrt(double(width * height)) / 8)
}

function get_booklet_list_width(Window window, int width = -1, int height = -1) returns int{
    if(width < 0){
        width = window.width
    }
    if(height < 0){
        height = window.height
    }
    return int(math.sqrt(double(width * height)) / 8)
}

function get_toolbar_items_count() returns int{
    var count = 11
    if(AppState:zone == Zone.Canvas){
        count++ // + 1 for the grid toggle
    }
    return count + 2 // + 2 for the logo and the space between the logo and the first item
}

function save(Booklet booklet, Theme theme, bool hasChanged, bool force = false){
    if(booklet.loaded){
        booklet.save(!hasChanged && !force)
        io.write_file(io.join_path([Booklet:getBookletsPath(), "current.txt"]), booklet.name)
    }
    if(theme == Theme.Light){
        io.write_file(io.join_path([Booklet:getBookletsPath(), "theme.txt"]), "light")
    }elseif(theme == Theme.Dark){
        io.write_file(io.join_path([Booklet:getBookletsPath(), "theme.txt"]), "dark")
    }
    io.write_file(io.join_path([Booklet:getBookletsPath(), "grid.txt"]), string(AppState:gridVisible))
}